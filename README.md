# Web Application Development Korean ver

목표: Web Application Development을 이해하고 나만의 web app을 만들어보자.

## Table of Contents

1. [Documentations](https://github.com/heeshin174/Web_App_Dev_Kor#documentations)
2. [Web Application에서 Server와 Cilent의 이해](https://github.com/heeshin174/Web_App_Dev_Kor#web-application%EC%97%90%EC%84%9C-server%EC%99%80-cilent%EC%9D%98-%EC%9D%B4%ED%95%B4)
3. [JavaScript](https://github.com/heeshin174/Web_App_Dev_Kor#javascript)

## Documentations

1. Frontend Framework (client side)

- React JS (Meta): https://reactjs.org/
- Angular jS (Google): https://angularjs.org/
- Vue JS: https://vuejs.org/
- React JS with Typescript: https://create-react-app.dev/docs/adding-typescript/

2. Sytling (client side)

- Bootstrap: https://getbootstrap.com/docs/5.0
- Tailwindcss: https://tailwindcss.com/docs/installation
- FontAwesome (icons): https://fontawesome.com/
- Devicon (icons representing programming languages, designing & development tools) https://devicon.dev/
- Google Font (text style) : https://fonts.google.com/
- styled-components: https://styled-components.com/docs


💥 ReactJS Framework (ReactJS Only):
- react-bootstrap (components): https://react-bootstrap.github.io/getting-started/introduction
- Material-UI (components): https://mui.com/
- React-icons (icons): https://react-icons.github.io/react-icons
- react-typed (Dynanic text): https://github.com/ssbeefeater/react-typed
- redux: https://redux.js.org/introduction/getting-started
- react-transition-group: https://reactcommunity.org/react-transition-group/
- react-redux: https://react-redux.js.org/
- redux-thunk: https://github.com/reduxjs/redux-thunk
- react-beautiful-dnd (drag and drop): https://github.com/atlassian/react-beautiful-dnd
- react-scroll (smooth scroll): https://github.com/fisshy/react-scroll
- react-router: https://reactrouter.com/docs/en/v6

3. Backend Framework (server side)

- Express js: https://expressjs.com/
- Next js (Server side rendering): https://nextjs.org/docs/getting-started
- Flask (python framework): https://flask.palletsprojects.com/en/2.0.x/
- Django (python framework): https://docs.djangoproject.com/en/4.0/
- nodemon (javascript framework: auto reload server): https://www.npmjs.com/package/nodemon)
- dotenv (javascript framework: set environmental variables): https://github.com/motdotla/dotenv
- concurrently (javascript framework: start client and server together): https://github.com/open-cli-tools/concurrently
- Axios (javascript framework: XMLHttpRequests): https://axios-http.com/docs/intro

4. Databases (server side)

- Mongodb: https://www.mongodb.com/cloud
- Mongoose js (Mongodb framework): https://mongoosejs.com/
- Postgresql: https://www.postgresql.org/download/
- PG-Pool js (Postgresql framework) : https://node-postgres.com/api/pool

5. Cloud Services

- AWS (Amazon Web Services): https://aws.amazon.com/
- Azure (Microsoft): https://azure.microsoft.com/en-us/
- GCP (Google Cloud Platform): https://cloud.google.com/

6. APIs

- RapidApi: https://rapidapi.com/

7. Deployment

- Github: https://github.com/
- Netlify: https://www.netlify.com/
- Heroku: https://www.heroku.com/

8. ETC

- Node js (Programming Language): https://nodejs.org/en/docs/
- Python (Programming Language): https://docs.python.org/3/
- Java (Programming Language): https://docs.oracle.com/en/java/javase/15/docs/api/index.html
- Typescript (Programming Language): https://www.typescriptlang.org/
- Docker (Container based development): https://www.docker.com/ & https://docs.docker.com/
- Postman (RESTful API): https://www.postman.com/downloads/
- VSCode (Microsoft IDE: Code Editor): https://code.visualstudio.com/
- Eclipse (Java IDE): https://www.eclipse.org/documentation/
- Goorm (Docker based Cloud IDE): https://www.goorm.io/
- Pythontutor (code visulaization): https://pythontutor.com/
- Figma (Design UI/UX): https://www.figma.com/
- Adobe photoshop (Design UI): https://www.adobe.com/products/photoshop
- Diagram.io (Design UI): https://app.diagrams.net/

9. Education

- Web Development In 2022 - https://www.youtube.com/watch?v=EqzUcMzfV1w&list=PLg8KC9DusHl8zGjAWYGGJygm3rWoEahJQ&index=30&ab_channel=TraversyMedia
- 기계들의 대화법 REST API - https://www.youtube.com/watch?v=PmY3dWcCxXI&list=PLg8KC9DusHl8zGjAWYGGJygm3rWoEahJQ&index=31&ab_channel=%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9
- 서버사이드 렌더링 - https://www.youtube.com/watch?v=iZ9csAfU5Os&list=PLg8KC9DusHl8zGjAWYGGJygm3rWoEahJQ&index=32&ab_channel=%EB%93%9C%EB%A6%BC%EC%BD%94%EB%94%A9by%EC%97%98%EB%A6%AC
- 웹개발 개념정리 - https://www.youtube.com/watch?v=ED2rOHM1od0&list=PLg8KC9DusHl8zGjAWYGGJygm3rWoEahJQ&index=33&ab_channel=%EA%B0%9C%EB%B0%9C%ED%95%98%EB%8A%94%EC%A0%95%EB%8C%80%EB%A6%AC
- Async Await: https://kiwanjung.medium.com/%EB%B2%88%EC%97%AD-async-await-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90-promise%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-955dbac2c4a4
- Closure & Hoisting: https://dongmin-jang.medium.com/javascript-closure-hoisting-7bf8eb5062b9
- Javascript closure: https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures
- w3school: https://www.w3schools.com/
- Leetcode: https://leetcode.com/
- redux 설명글: https://hwan1001.tistory.com/38
- react로 만든 웹 github로 deploy하기: https://codingapple.com/unit/react-build-deploy-github-pages/

## Web Application에서 Server와 Cilent의 이해

### 1. What is SERVER?

**Server는 Client에게 Network를 통해 http요청을 받아서 정보, data, 서비스등을 전달하는 Computer이다.**

Server와 cilent는 web application에서 computer가 하는 역할을 의미한다. 사람이 학교에서 학생, 선생님, 청소부와 같은 role를 맡는 것처럼,
Computer가 web app에서 server, cilent와 같은 role를 가진다. 한 computer가 server의 역할을 하고 있으면, 다른 computer가 cilent가 되어 이 server에 데이터를 요청할 수 있다.

Server는 한 computer가 맡는 role로, 식당에서 종업원이 하는 일이랑 똑같은 일을 한다. 종업원이 손님이 메뉴판에 있는 음식을 주문하면, 그 음식을 가져다 주는 것처럼, Server는 Client가 요청하면 요청한 것을 가져다 주는 역할을 한다. 

- **Server: 요청을 받으면 요청한 내용을 보내주는 program이 실행중인 Computer**
- Server 개발자: 요청을 받으면 요청한 내용을 보내주는 program을 만드는 사람.
- 네이버웹툰 Server 개발자가 만드는 code: 어떤 사람이 `comic.naver.com`으로 접속하면, 네이버웹툰 메인 html파일을 전송해주셈


위의 Server에 대한 정의를 쉽게 이야기하면, **Server는 요청을 받아 그 요청을 처리하는 기계이다.** 우리가 계속 이야기한 요청은 `http 요청 (request)`을 의미한다.

Client가 Server에게 할 수 있는 http요청은 크게 4가지이다:

1. GET요청: 읽기
2. POST요청: 쓰기
3. PUT요청: 수정
4. DELETE요청: 삭제

설명: 여기서 알아야 할 점은 사용자도 http request를 보내는 code를 작성해야지만 server와 정보를 주고 받을 수가 있다는 점이다. 사용자는 GET 요청같은 경우, code는 browser의 URL 창에서 쉽게 작성이 가능하고, 다른 POST/PUT/DELETE 요청들은 Server 개발자가 웹페이지에 Button을 만들어 놓아서 사용자가 code창에 code를 작성하는 것이 아니라 웹페이지에서 쉽게 http request를 할 수 있도록 만들어 놓아야 한다.  

- 즉, 웹 개발자가 http요청을 하는 버튼들을 웹페이지에 잘 만들어 놓으면, 사용자는 그냥 클릭만으로 http요청을 할 수 있다.

1. GET요청은 읽기 요청으로 서버에 "나 이런 URI을 가진 페이지를 읽고 싶음"이라는 요청을 보낼 수 있다. 우리가 Server에 가장 많이 하는 요청으로 Chrome, dge와 같은 browser로 URL만 검색하면 GET요청을 할 수 있다.

2. POST요청은 생성 요청으로 서버에 "내가 작성한 블로그 포스트, 글, 댓글등을 생성해 주세요"라는 요청을 보낼 수 있다.

3. PUT요청은 수정 요청으로 서버에 "기존에 작성한 블로그 포스트, 글, 댓글등을 수정해 주세요"라는 요청을 보낼 수 있다.

4. DELETE요청은 수정 요청으로 서버에 "기존에 작성한 블로그 포스트, 글, 댓글등을 삭제해 주세요"라는 요청을 보낼 수 있다.

⭐ 요약:

1. **SERVER: Client의 요청을 처리하는 computer**
1. **WEB SERVER: Client로 부터 http요청을 받으면 정의된 대로 요청을 처리하는 program이 실행중인 computer**
2. **CLIENT: Server에 정의된 대로 GET/POST/PUT/DELETE요청을 보내는 computer**


### 2. What is APIs (Application Programming Interface)?

**API는 한 program에서 다른 program으로 data를 주고받기 위한 방법을 의미한다.**

API는 식당에서의 메뉴판과 같은 역할을 한다고 이해하면 쉽다. 식당의 API는 메뉴판으로, 식당과 손님이 음식을 주고받기 위한 방법이다. 
식당은 메뉴판을 만들어 놓고, 손님이 음식을 주문 하기 전까지는 아무것도 하지 않는다.
또한 손님이 메뉴판에 정의되지 않은 음식을 주문하면, 그 주문은 받을 수가 없다.

이와 마찬가지로, Server 역시 메뉴판, 즉 API를 만들어 놓아야지만 그 API를 가지고 Client와 data를 주고 받을 수 있다.
Server는 Client에게 **http요청**을 받지 않으면, 아무것도 하지 않는다. 또한, 손님은 메뉴판에 없는 요리는 주문할 수 없는 것처럼, Client는 Server에 정의되지 않은 API를 가지고 http요청은 할 수 없다.

```
// 식당에서의 Server와 Client
1. 손님이 식당에 있는 메뉴판을 보고 종업원에게 주문 요청
2. 종업원은 손님의 주문을 받아 요리사에게 전달
3. 종업원은 요리사의 음식을 받아 손님에게 전달

      1                    2
손님    ------->   종업원   ------>   요리사
       <-------            <------
      4                    3

// Web application에서의 Server와 Client
1. Client는 Server가 보여주는 API을 보고 Server에게 HTTP 요청 (http request)
2. Server는 Client의 http요청을 받아 Database에게 전달
3. Server는 Database의 data를 받아 Client에게 전달 (response)

       1.http request          2.request
Client ------->      Server     ------>  Database
       <-------                 <------
      4.response                3.get data
```

위에서 API는 서버와 사용자가 데이터를 주고 받기 위한 방법이라고 했는데, 여기서 방법이란 그냥 개발자가 만들어 놓은 코드를 의미한다.
웹 서버의 경우, 서버 개발자가 사용자의 http요청을 받았을 때 Server가 할 행동들을 미리 정의해 둔다. 그 후 만들어 놓은 Server의 행동들, 즉 API을 메뉴판처럼 사용자에게 보여주면 된다. 

```
// API 예시
// 어떤 사용자가 "https://~/detail"로 GET요청을 하면 이 코드를 실행해 주세요
app.get('/detail', (request,response) => {
//code to perform particular action (API).
//To access GET variable use req.query() and req.params() methods.
});
```

Server의 API를 성공적으로 작동하기 위해서는 다음이 필요하다.

1. 요청방식 (http request method): 어떤 요청을 할 것인지 
2. URI (endpoint): 어떤 자료를 요청할지
3. Parameter: 자료요청에 필요한 추가 정보

예시: `(GET request) https://comic.naver.com/webtoon/detail?id=318995`

1. 요청방식: GET request 
2. Endpoint: `https://comic.naver.com/webtoon/detail`
3. Parameter: `id=318995`

Web Server의 경우 `REST API`라는 방법론의 원칙에 따라 API를 작성하면 좋다.

API는 상업적으로 팔 수 있다. API hosting service를 이용하여 정해진 횟수 이상의 데이터 요청이 발생하면, 돈을 지불하게 만들 수 있다. 

⭐ 요약:

1. **API: 한 program에서 다른 program으로 data를 주고 받는 요청을 처리하는 code**
2. **Web Server에서의 API: Client로 부터 http요청을 받았을 때, 그 요청을 처리하는 code**


### ⭐ 3. REST (Representational State Transfer) APIs

**REST (REpresentational State Transfer): "분산 시스템"을 위한 HTTP 기반 software architecture**

즉, 웹 어플리케이션, 다양한 언어, 모바일 어플리케이션, 다른 서버 (전부 HTTP 기반) 등 끼리 서로 통신할 수 있도록, 통역 역할을 해주는 API.

분산시스템은 하나의 시스템으로 보이는 독립된 컴퓨터들의 집합으로, 이를 위해 네트워크를 통한 컴퓨터 간의 통신이 필요하다.

REST는 Representational State Transfer라는 용어의 약자로서 2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개되었습니다. 로이 필딩은 HTTP의 주요 저자 중 한 사람으로 그 당시 웹(HTTP) 설계의 우수성에 비해 제대로 사용되어지지 못하는 모습에 안타까워하며 웹의 장점을 최대한 활용할 수 있는 아키텍처로써 REST를 발표했다고 합니다.

REST API는 크게 세가지로 구성으로 이루어져있습니다:

1. 자원(RESOURCE) - URI (접근할 대상)
2. 행위(Verb) - HTTP METHOD: GET(조회), POST(생성), PUT(수정), DELELTE(삭제)
3. 표현(Representations) - Message

REST API 디자인 가이드

REST API 설계 시 가장 중요한 항목은 다음의 2가지로 요약할 수 있습니다.

1. **URI는 정보의 자원을 표현해야 한다.**
2. **자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.**

```
1. 회원을 삭제하는 URI
GET /members/delete/1   (x)
DELETE /members/1       (o)

2. 회원정보를 가져오는 URI
GET /members/show/1     (x)
GET /members/1          (o)

3. 회원을 추가하는 URI
GET /members/insert/2 (x)  - GET 메서드는 리소스 생성에 맞지 않습니다.
POST /members/2       (o)
```

URI를 설계할 때 주의할 점:

1. 슬래쉬 구분자(/)는 계층 관계를 나타내는 데 사용

```
http://restapi.example.com/houses/apartments
http://restapi.example.com/animals/mammals/whales
```

2. URI 마지막 문자로 슬래시(/)를 포함하지 않는다.
URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 합니다. REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않습니다.

```
http://restapi.example.com/houses/apartments/ (X)
http://restapi.example.com/houses/apartments  (0)
```

3. 하이픈(-)은 URI 가독성을 높이는데 사용
URI를 쉽게 읽고 해석하기 위해, 불가피하게 긴 URI경로를 사용하게 된다면 하이픈을 사용해 가독성을 높일 수 있습니다.

4. 밑줄(_)은 URI에 사용하지 않는다.
글꼴에 따라 다르긴 하지만 밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 합니다. 이런 문제를 피하기 위해 밑줄 대신 하이픈(-)을 사용하는 것이 좋습니다.(가독성)

5. URI 경로에는 소문자가 적합하다.
URI 경로에 대문자 사용은 피하도록 해야 합니다. 대소문자에 따라 다른 리소스로 인식하게 되기 때문입니다. RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문이지요.

```
RFC 3986 is the URI (Unified Resource Identifier) Syntax document
```

6. 파일 확장자는 URI에 포함시키지 않는다.

```
http://restapi.example.com/members/soccer/345/photo.jpg (X)

// REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않습니다. Accept header를 사용하도록 합시다.
GET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg
```

Below is a table summarizing recommended return values of the primary HTTP methods in combination with the resource URIs:

| HTTP Verb | CRUD   | Entire Collection (e.g. /customers) | Specific Item (e.g. /customers/{id})                                       |
| --------- | ------ | ----------------------------------- | -------------------------------------------------------------------------- |
| POST      | Create | 201 (Created)                       | 404 (Not Found), 409 (Conflict) if resource already exists..               |
| GET       | READ   | 200 (OK)                            | 404 (Not Found), if ID not found or invalid.                               |
| PUT/PATCH | UPDATE | 405 (Method Not Allowed)            | 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. |
| DELETE    | DELETE | 405 (Method Not Allowed)            | 200 (OK). 404 (Not Found), if ID not found or invalid.                     |

Postman is great program to build an RESTful web services.
- Postman POST요청 사용법:

1. POST의 Header에서 `Content-Type:application/json`을 선택한다.
2. POST의 Body에서 row 선택후, Post하고자 하는 데이터를 Json 형식으로 입력한다.
 
![POST1](./img/postman1.png)
 
![POST2](./img/postman2.png)

⭐ 요약:

1. **REST API: Web 통신에서 사용자로 부터 http요청을 받을 URI를 설계할 때 지켜야 되는 방법론**
2. **REST API를 사용하면, 사용자는 URI 주소만 가지고도 내가 무슨 Data를 다루고 있는지 쉽게 알 수 있다.**


### 4. What is Node JS?

**Node Js는 Javascript runtime이다.**

Javascript는 HTML에 종속된 programming language이다. 즉, 1 + 1과 같은 연산을 위해 만든 것이 아니라 HTML을 조작하기 위해서 만들어진 script이다.

HTML: 웹페이지에 글쓰고, 그림을 넣은 언어로, 프로그래밍언어가 아니기 때문에 정적인 (static: 안움직이는) 웹사이트만 보여줄 수 있다.

Javascript가 HTML을 조작하여 웹페이지를 동적 (dynamic)으로 바꿔준다. 예): 버튼을 클릭하면 어떤 동작이 실행됨.

Javascript는 Chrome, Edge와 같은 browser가 해석한다. 각 browser마다 Jvascript를 해석하는 방법이 다른데, 그 중 Chrome이 만든 `V8`이라는 javascript 해석엔진이 너무 유용해서 Chrome browser안에서만 사용하기에는 아까워서 `Node Js`라는 이름을 가지고 browser와 독립되서 나왔다. 

즉, `Node Js` 자체로는 프로그래밍 언어가 아니라 Javascript를 실행하게 해주는 실행 환경을 의미한다. `Node Js`덕분에 Javascript를 browser밖에서 Programming Language처럼 사용할 수 있게 되었다.

Node Js로 할 수 있는 대표적인 것은 **Server를 만드는 것**이다. Node Js를 사용하면 Server를 쉽게 만들 수 있다.

왜 하필 Node Js를 이용하여 Server를 만드는 것이 좋냐하면 Node Js의 특징인 **Non-blocking I/O** 때문이다.

Node Js의 특징:
1. **Non-blocking I/O**
2. **Event-driven**

설명: Non-blocking I/O operations allow a single process to serve multiple requests at the same time. Instead of the process being blocked and waiting for I/O operations to complete, the I/O operations are delegated to the system, so that the process can execute the next piece of code.
즉, Non-blocking I/O은 Server가 버거운 요청을 받아도, 그 요청이 끝날 때까지 기다리지 않고 더 빨리 끝나는 요청을 먼저 처리한다.

```
예시: 사용자의 요청에 따라 영화를 예매하주는 서버

1. 일반 프로그래밍 언어로 만든 서버
사용자가 티켓한장, 두장과 같이 적은 수을 요청하면 문제가 없지만, 
사용자가 시간이 오래걸리는 요청, 티겟 200장을 예매하면, 서버는 그 요청을 다 완료할 때까지 멈추게 된다.
이렇게 되면, 티겟 200장 예매한 사람 뒤에 있는 티켓 1장을 예매한 사람 역시 티켓 200장이 예매가 완료될 때 까지 서버를 기다려야 한다.

2. Node Js로 만든 서버
사용자가 시간이 오래걸리는 요청, 티겟 200장을 예매해도 서버는 그 요청을 다 완료할 때까지 멈추지 않고, 
티겟 200장 예매한 사람 뒤에 있는 티켓 1장을 예매한 사람 먼저 처리를 한 다음에 티켓 200장을 처리한다.
```

Node JS는 이벤트를 적극 활용하여 처리가 빠른 것 부터 실행하기 때문에 요청이 매우 많이 오는 채팅, SNS Web server를 만들 때 적극 선호됩니다.
물론 다른 언어들도 이런 식으로 서버를 짤 수 있기 때문에 요즘은 장점이 희석되긴 했지만, 또 하나 극강의 장점 덕분에 서버 개발 입문자에게 선호도가 높습니다.
바로 코드가 매우 짧고 쉽다는 점이다.

하지만, 만약 필요한 서버가 웹 서버가 아니라면, Node js보다는 Python과 C같은 언어들을 사용하는 것이 좋다.

⭐ 요약:

1. **Node Js: browser내에서만 사용가능한 Javascript를 browser 밖에서도 사용가능하게 만든 Javascript 실행환경**
2. **Node Js는 다른 프로그래밍 언어와 다르게 Non-blocking I/O의 특징을 가져, 시간이 오래걸리는 code들을 기다리지 않고, 다음 code를 실행한다.**
3. **Node Js를 이용하면 쉽고, 빠르게 웹서버를 만들 수 있다**

### 5. Node Js와 Express Js framework를 이용하여 실제 Server 만들기

Express Js framework은 the most popular Node web framework으로, 아주 간단하게 Server를 만들 수 있도록 도와주는 package이다.

환경설정:

1. Node Js 설치: 구글에 Node Js 검색 후, 가장 최신버전 설치
2. VSCode 설치: 구글에 VSCode 검색 후, 가장 최신버전 설치
3. VSCode에 Terminal (CMD)을 열어 folder 생성 후, 그 안에 express js 설치

npm stands for node package manager. npm은 프로그램의 dependencies (packages)를 설치하는 것을 도와준다.

package.json 생성 (이 프로그램이 사용하는 dependencies (packages)을 모아둔 파일)
> `npm init

이러면, node_modules란 folder가 생성되는 데, 이 folder에는 다운 받은 packages의 실제 source code가 담겨있다.

Express Js을 이 프로그램에 설치
> `npm i express`

4 .server.js file을 생성 후, express js 가져오기

```
// server.js
const express = require('express'); // import express js framework
const app = express();

// app.listen(서버를 띄울 port number, 서버를 띄운 후 실행할 코드)
// 8080 port에 웹서버를 생성 후, 서버가 잘 생성이 되면 "Listening on 8080"을 출력한다.
// 여기서 port란: Copmuter에는 외부와 Network 통신을 하기 위해 60000개의 구멍이 존재하고, 각각의 구멍이 하나의 port가 된다.
// 8080 port는 8080 구멍으로 들어오는 통신만, 이 서버를 띄운다.
app.listen(8080, function() {
    console.log("Listening on 8080");
})
```

5. server를 실행하기

> `node server.js`

6. 내 컴퓨터의 8080 port에 진입하기

Browser에서 `http://localhost:8080`에 Get 요청을 보내면, 내 컴퓨터의 8080 port에 접근할 수 있다.

7. Get 요청에 응답할 code 작성하기

```
// 사용자가 '/pet'으로 Get 요청을 보내면, pet과 관련된 안내문을 띄우기  
app.get('/pet', function (req, res) {
    res.send("This is pet page")
});

// Browser에서 `http://localhost:8080/pet`에 Get 요청을 보내면, "This is pet page"라는 문구를 확인할 수 있다.
```

이는 내 컴퓨터의 8080port이므로, 다른 컴퓨터로 위의 localhost URI를 검색하면, 그 컴퓨터의 8080 port에 접근하기 때문에 이 Server에는 접근할 수 없다.

8. nodemon js library로 코드 수정시 서버 재시작을 자동화하기

우리가 코드를 수정하면, 수정할 때마다 서버를 `CTRL + C`로 종료하고 `node server.js`로 서버를 다시 시작해야 한다. 

그럼으로 nodemon js library로 코드 수정시 서버 재시작을 자동화한다.

nodemon은 개발할 때만 사용할 dependency이기 때문에, -D를 붙혀 실제 production에서는 설치하지 않는다.

> `npm i -D nodemon`

```
// package.json의 scripts에 다음의 코드를 추가한다.
"scripts": {
  "start": "node server.js",
  "server": "nodemon server.js"
},
```

- start: start the server. but need to restart the server after every server-side change.
- server: start the server. nodemon continuously watch the server, and we won't have to keep updating it.

server는 개발할 때만 사용할 command이다.

To use these command, type:

> `npm start`
> `npm run server`

우리는 이제 `node server.js` 대신 `npm start`로 웹서버를 실행시킬 수 있고, `npm run server`로 nodemon을 이용하여 server를 개발할 수 있다.

9. Get 요청시 html file을 주는 code 작성하기

```
// 사용자가 '/'으로 Get 요청을 보내면, index.html file 보여주기
app.get('/', function (req, res) {
    res.sendFile(__dirname + "/index.html"); // __dirname은 current directory를 반환한다. 
});

// Browser에서 `http://localhost:8080`에 Get 요청을 보내면, index.html file을 확인할 수 있다.
```

10. Node Js의 common Js syntax를 ES6 syntax로 변경하기 (Optional)

Node Js는 common Js의 syntax을 채용하였다. 그래서, 다른 files을 불러오거나 내보낼 때 (import/export), common Js syntax인 `require('module_name')`와 `module.export "module_name"`을 사용한다.

이는 다른 Java와 같은 programming language에서는 볼 수 없는 방식으로, 우리는 ES6 syntax인 `import`과 `export`이 편하기 때문에 Server를 ES6 syntax로 바꾸어 볼 것이다.

In order to enable Node support for ES modules we need to tweak the package.json file. In the package.json file add "type": "module" to the root of the file.

```
// package.json에 "type": "module" 추가하기
{
  "name": "index",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "server": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
  "dependencies": {
    "express": "~4.16.1",
  } "devDependencies" : {
    "nodemon": "~2.0.15"
  }
}
```

Then run the following command to update changes to package.json

> `npm i`

Once we have updated our package file we have to make the relevant changes to our app's code as follows:

```
import express from 'express';

const app = express();

app.get('/',(req,res) => {
    res.send('ES6 is the Node way to go');
})

app.listen(3000,() => {
    console.log(`App listening on port 3000!`);
})
```

```
// arrow function
app.get('/',(req,res) => {
    res.send('ES6 is the Node way to go');
})

// regular function
app.get('/',function (req,res) {
    res.send('ES6 is the Node way to go');
})
// 함수를 정의하는 데에는 function keyword를 사용하거나 arrow function을 사용하는 방법이 있다.
```

⭐ 요약:

1. **Node js와 Express Js framework를 사용하면, 아주 쉽고 간편하게 web server를 만들 수 있다.**
2. **Computer에는 외부와 네트워크로 소통할 수 있는 port (구멍)들이 존재하고, localhost:{port}를 browser에 검색하면 내 컴퓨터의 특정 port에 접근할 수 있다.**


### 6. Server 운영 방식에 차이 이해하기

우리가 해외로 파견을 나가 작업을 해야할 때, 큰 회사의 호텔을 이용하거나, 건물을 빌려 사용할 수 있다.

호텔을 이용하면, 빨래, 청소, 식사등 많은 것을 호텔 측에서 해주기 때문에, 나는 내가 할 작업에만 집중할 수 있다.
작업을 같이하는 인원에 변동이 생겨도, 호텔의 방을 더 빌리거나, 줄일 수 있기 때문에 인원수에 맞게 이용할 수 있다.
호텔이 보안에 모든 것을 관리하기 때문에 보안에 민감한 작업팀에게는 맞지 않다.

건물을 빌리면, 빨래, 청소, 식사등 많은 것을 직접해야 하기 때문에, 내가 할 작업에만 집중할 수 없다.
작업을 같이하는 인원에 변동이 생기면, 인원수에 맞게 새로운 건물을 빌려야 한다.
대신, 내가 모든 것을 관리하기 때문에 보안 문제에 더 안전하게 대처할 수 있다.

회사가 server를 운영하는 방식인 On-premise방식과 Cloud computing service 방식을 각 각
건물을 빌리는 것과 호텔을 이용하는 것에 비유할 수 있다.

1. On-premise 방식:
   회사가 집적 물리적인 computer를 사서, 그 computer를 server로 만든다.
   이 방법은 computer를 직접 사야함으로 Cloud Computing service보다 더 많은 돈이 요구된다.
   black friday와 같이, 특정날에 사용자가 많아져 server를 늘리려면, 새로운 computer를 또 사야하고
   이 시즌이 지나면 그 computer는 다시 사용되지 않는다.
   server를 사용자에 맞게 scale-up, scale-down하기 쉽지 않아 자원에 낭비가 생긴다.
   대신, 회사가 집적 관리하기 떄문에 보안 문제에 더 안전하다.

2. **Cloud Computing Service** 방식:
   위에서 호텔이 여려 방을 제공한다고 했는데,
   cloud computing에서는 virtualization을 이용하여 한 물리적 computer에 여러대의 가상 computer를 만들 수 있다
   (virtualBox에 ubuntu를 설치하는 것을 생각하면 된다).
   대기업에서 제공하는 Cloud computing service를 이용하면, 회사는 물리적인 computer 자원을 사지않고
   저렴한 가격에 server를 운용할 수 있다.
   black friday와 같이, 특정날에 사용자가 많아지면, server를 늘리는 일에 아주 적합하다.
   server를 사용자에 맞게 scale-up, scale-down하기 쉽기 때문에, 자원에 낭비가 없고,
   내가 사용한 만큼만 돈을 지불하면 된다 (pay-as-you-use).

```
Amazon사의 AWS (Amazon web services),
Microsoft사의 Azure,
Google사의 GCP (Google cloud platform)등이 cloud computing service를 제공하는 대표적인 사이트이다.
```

각 방식의 장점 요약:
On-premise: security
Cloud Computing service: money, scale-up & down, fast set up

Cloud Computing service가 어디까지 service해주는 가에 따라 service를 세 가지로 나눌 수 있다.
Iaas (Infrastructure as a service): AWS EC2 가상 머신,
Paas (platform as a service): AWS Elastic Beanstalk,
Saas (Software as a service): youtube, evernote, dropbox, Amazon Web Services (AWS)

이런 cloud computing service의 엄청난 장점 덕분에 대세로 떠오르고 있다.
예로, brainless machine을 생각할 수 있다. 기존에 machine을 만드려먼 그 machine에 들어갈 비싼 computer 부품들을
직접사서 조립해야 했지만, 이젠 machine이 network에 연결만 되어 있으면 cloud Computing service의 computer를 가져다
사용하면 된다.

기존 machine: 실제 computer 부품 구매, 200만원
brainless machine: network를 사용하여 더 좋은 computer를 더 싸게 이용, 50만원

⭐ 요약:

1. **Cloud Computing Services는 내 컴퓨터가 아닌 각 Cloud computing service의 데이터베이스에 있는 computer들로 Server를 운영하기 때문에, 내가 직접 컴퓨터를 안사도 인터넷만 있으면 더 싼 가격에 더 좋은 컴퓨터로 나의 Server를 운영할 수 있다.**
2. **Cloud Computing Services로 Server를 운영하면 money, scale-up & down, fast set up에 엄청난 강점이 존재한다.**

## Framework vs Library

- Framework를 한국어로 하면 frame (틀), work (작업), 즉 기본적인 틀을 만드는 작업이다.
  framework는 기본적인 사용방법이 존재하기 때문에 우리는 이 기본적인 뼈대에다가 살을 붙이면 된다.

- Library는 특정 기능에 대한 도구 or 함수들을 모은 집합입니다.
  즉, 프로그래머가 개발하는데 필요한 것들을 모아둔 것입니다.
  library는 단순 활용이 가능한 도구들의 집합

집을 만드는 작업이라고 하면,
framework는 집의 기본 구조를 제공하여, 우리는 그 구조에 더하면 되고,
library는 침대, 소파와 같은 가구로, 우리는 이 가구들로 집을 만들어야 한다.

## ⭐ Frontend framework vs Server-Side Web Framework
Web App dev는 크게 Frontend, Backend, Database로 나눌 수 있고, 이 세가지를 합쳐 Fullstack dev라고 한다.
이는 MVC (Model / View / Controll) software design pattern 라고도 불린다. 
Model–view–controller is a software design pattern commonly used for developing user interfaces that divide the related program logic into three interconnected elements.

- Model은 View와 Controll을 연결하는 연결고리 역할을 한다.
- View은 client가 웹사이트에 방문하여 실제로 보게되는 회면을 의미한다. HTML (HyperText Markup Language), CSS (Cascading Style Sheets), Javascript를 이용하여 View를 작성할 수 있다. 여기서 programming language는 오직 Javascript이다.
- Controll은 app의 functionalities를 의미한다.  

각각의 programming language마다 Web Application Server를 만드는 web app framework를 제공한다.

1. python: Django, Flask, FastAPI
2. Java: spring, spring boot, play
3. Javascript: Express, Fastify
4. php: Laravel

![This is an image](./img/server_side_web_framework.png)

`Frontend framework`은 pure Javascript, HTML이 아닌 web view를 더 쉽게 작성할 수 있게 만드는 framework이다.
SPA를 제공하는 frontend framework에는 크게 React JS, Vue JS, Angular JS가 있다.
**Single Page Application** (SPA)는 body가 비어있는 하나의 HTML을 가지고 Javascript를 이용해서 그 안에 Data만 변경하는 것을 말한다.
Server가 Client에 자료를 넘겨주면, Client computer가 그 정보를 가지고 HTML를 완성하기 때문에
CSR (Client Side Rendering)이라고 부른다. CSR은 HTMl이 비어있기 때문에 검색 엔진에 노출되어 검색되기 쉽지 않다.
SEO (Search Engine Optimization)에 약점을 가진다.

⭐ `React JS`: React는 Meta사에서 만든 Javascript frontend framework로 computer에 최신 버전의 `node js`를 설치하면 누구나
쉽게 사용할 수 있다.

그 밖에도 google사에서 만든 `Angular JS`,

`Vue JS`등 다양한 Web Application Frontend framework이 존재한다.
이 Web application framework은 사용방법이 거의 비슷하기 때문에 하나만 잘 이해하면, 나머지는 쉽게 사용할 수 있다.

`Figma`, `Adobe photoshop` 등 다양한 Moderm UI/UX (web view)를 실질적으로 코드를 작성하기 전에 디자인할 수 있는 program들이 많이 존재하므로, 이를 이용하여 웹사이트를 미리 디자인 해 볼 수도 있다. 

## Server-Side Rendering (SSD)

SSD는 CSD가 가진 검색 엔진에 대한 보완을 위해 등장한 개념으로, CSD와는 다르게 Server에서 HTML을 전부 완성한 후에 Client에게 보내준다.
이로 인해 이용자가 많을 경우 Server에 과부화가 걸릴 수도 있다.

## Database

Database와 web app을 연결하여 쉽고 간단하게 data를 읽고 쓸 수 있다.
Database는 크게 Relational database (sql)와 Not only Relational database (Nosql)로 나눌 수 있다.
`sql (Structured Query Language)`

⭐ `postgresql` - Relational database의 대표주자

⭐ `Mongo Database` - Not only Relational database의 대표주자
![This is an image](./img/Database.png)

## Deploy Frontend Projects

⭐ `Netlify`, `heroku`, `Github`등을 이용해 내가 만든 웹사이트를 배포할 수 있다.

## % 부록1 Docker 이해하기 %

local computer에 다운되어 있는 environment와 server computer에 다운되어 있는 environment가 다르면
local에서 작성된 code는 server에서 호환성 문제로 작동이 안될 수도 있다.
이 문제를 해결하기 위해 container라는 개념이 등장하였고,
Docker가 container를 제공하는 가장 큰 platform이다.
Docker는 서비스를 제공할 때, 아주 쉽고, 빠르고, 간단하게 같은 environment의 container를 만드는 것을 도와준다.

Dockerfile로 image를 만들고 (build),
image로 container를 실행한다 (run).

Dockerhub에서 공식적인 image을 다운 받을 수도 있고, 내가 customized한 image도 upload할 수 있다.

기본 구조: Dockerfile -build> Dokcer image -run> Docker container

- Dockerfile로 image를 build하는 commend

  > $ docker bulid -t imageName
  > local computer에 이 이미지가 존재하지 않으면, Dockerhub에서 image을 다운 받는다.

- image로 container를 run하는 commend
  > $ docker run -it imageName
  > $ docker run -b imageName
  > (d는 daemon의 약자로 뒤에서 작동한다.)

## % 부록2 git으로 다른 programmer와 collaboration 하기 %

Git의 "master" branch는 항상 완전환 코드이어야 한다.

다른 사람이랑 협업을 할 경우에 issues, pull request를 잘 활용하여, 프로젝트를 성공적으로 완성해 보자.

- issues: 코드에서 고쳐야 할 부분
- pull request: master branch에 merge하기 전에 내가 고친 코드를 다른 협업자가 관찰하고 이상이 없는 지 확인하는 단계

Git 사용법:

1. 소스 코드를 다운 받기

   > $ `git clone https:...` or Download zip file

2. Always start your branch with what is in the remote/main, so after you have cloned the repository locally 
 
모든 branch를 출력
   
  > $ `git branch`

branchName brannch로 이동

> $ `git checkout -b branchName`

> Your branch is up to date with 'origin/main'.

3. 새로운 branch를 만들어서 main branch 에서 만든 branch로 이동하기
   now that your local matched the most up to date stuff, switch to a branch for your own work.

> $ `git switch -c branchName`

4. 소스 코드에 변화를 만든 후, pull request하여 다른 협업자가 볼 수 있게 하기
   
Do your thing, then when your ready to push, open terminal back up and make sure your in the base directory for the project:

Stage all your changes for commit

> $ `git add .`

Commit your changes

> $ `git commit -m "My Commit Message, what did I do today?"`

Push your commit to a remote branch (probably want to use your same local branch name)

> $ `git push --set-upstream origin branchName`

 `git push -u origin master` command는 main branch에 code를 push 하는 것입니다.

main은 항상 완벽한 완결된 코드이어야 함으로 main에 직접적으로 push하는 것은 지양해야 합니다.

위에 서술된 방법으로, 새로운 branch를 만들어서 pull request를 하면된다.

> $ `git push -u origin master`

요약:
```
1. In terminal type: `git clone https:...`
2. Make changes to the code
3. Once you finish, type: `git add .`
4. Commit your work: `git commit -m "what i did"`
5. Create new branch or Move to the existing branch
- Create and move to new branch: `git checkout -b <branchName>`
- Move to the existing branch: `git switch -c <branchName>`
6. push your work to that branch: `git push -u origin <branchName>`
```

## % 부록3 Amazon사의 cloud service인 AWS (Amazon Web Service) 사용하기 %

1. AWS IAM - User를 생성하고, create access key를 사용하여, API에 접근하기

2. AWS S3 - bucket을 만들어 파일 저장하기

3. AWS SES (Simple Email Service) - email 보내기

4. AWS EC2 가상환경 - virtualBox와 같이 가상 환경을 제공

5. AWS Lambda - 함수

6. AWS Elastic Beanstalk - 간단히 코드를 배포할 때 사용


# Javascript

Javascript는 web browser를 위해 등장한 programming language이기 때문에 다른 프로그래밍 언어들과는 차별점을 가진다.

1. Javascript는 비동기 프로그래밍언어(asynchronous programming) 이다.
자바스크립트의 비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 자바스크립트의 특성을 의미합니다.
데이터를 불러오는데 오래걸리는 것들을 기다리지 않는다.

2. variable을 지정했는데 값을 아직 assign 안한 경우, 이 변수의 값은 undefined이 된다.

- Javascript에서 string안에 값을 변경하려면 back tic `${variable}`을 사용해야 한다.

```
const name = "Shin";
console.log(`Hello ${name}!`);
```

- object는 **{} curly braces**를 이용해서 정의한다.

## 💥 Callback vs Promises vs Async Await:

Javascript는 asynchronous programming로 데이터를 요청하는 데 시간이 많이 걸리는 line이 있으면, 그 code의 값을 기다리지 않고 다음 code를 시작한다.

비동기 처리 사례는 setTimeout()입니다. setTimeout()은 Web API의 한 종류입니다. 코드를 바로 실행하지 않고 지정한 시간만큼 기다렸다가 로직을 실행합니다. 아래 코드를 보겠습니다.

```
// #1
console.log('Hello');
// #2
setTimeout(function() {
	console.log('Bye');
}, 3000);
// #3
console.log('Hello Again');
```

비동기 처리에 대한 이해가 없는 상태에서 위 코드를 보면 아마 다음과 같은 결과값이 나올 거라고 생각할 겁니다.

```
‘Hello’ 출력
3초 있다가 ‘Bye’ 출력
‘Hello Again’ 출력
```

그런데 실제 결과 값은 아래와 같이 나오죠.

```
‘Hello’ 출력
‘Hello Again’ 출력
3초 있다가 ‘Bye’ 출력
```

setTimeout() 역시 비동기 방식으로 실행되기 때문에 3초를 기다렸다가 다음 코드를 수행하는 것이 아니라 일단 setTimeout()을 실행하고 나서 바로 다음 코드인 console.log('Hello Again');으로 넘어갔습니다. 따라서, ‘Hello’, ‘Hello Again’를 먼저 출력하고 3초가 지나면 ‘Bye’가 출력됩니다.

### Call Back Function으로 비동기 프로그램이 가진 문제 해결하기

콜백 함수의 동작 방식은 일종의 식당 자리 예약과 같습니다. 일반적으로 맛집을 가면 사람이 많아 자리가 없습니다. 그래서 대기자 명단에 이름을 쓴 다음에 자리가 날 때까지 주변 식당을 돌아다니죠. 만약 식당에서 자리가 생기면 전화로 자리가 났다고 연락이 옵니다. 그 전화를 받는 시점이 여기서의 콜백 함수가 호출되는 시점과 같습니다. 손님 입장에서는 자리가 날 때까지 식당에서 기다리지 않고 근처 가게에서 잠깐 쇼핑을 할 수도 있고 아니면 다른 식당 자리를 알아볼 수도 있습니다.

자리가 났을 때만 연락이 오기 때문에 미리 가서 기다릴 필요도 없고, 직접 식당 안에 들어가서 자리가 비어 있는지 확인할 필요도 없습니다. 자리가 준비된 시점, 즉 데이터가 준비된 시점에서만 저희가 원하는 동작(자리에 앉는다, 특정 값을 출력한다 등)을 수행할 수 있습니다.

### Promise

“A promise is an object that may produce a single value some time in the future”

Promise가 왜 필요한가요?
프로미스는 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다. 
일반적으로 웹 애플리케이션을 구현할 때 서버에서 데이터를 요청하고 받아오기 위해 아래와 같은 API를 사용합니다.

```
app.get('url 주소/products/1', function(response) {
  // ...
});
```

위 API가 실행되면 서버에다가 ‘데이터 하나 보내주세요’ 라는 요청을 보내죠. 그런데 여기서 데이터를 받아오기도 전에 마치 데이터를 다 받아온 것 마냥 화면에 데이터를 표시하려고 하면 오류가 발생하거나 빈 화면이 뜹니다. 이와 같은 문제점을 해결하기 위한 방법 중 하나가 Promise이다.

There are 3 states of the Promise object:

프로미스를 사용할 때 알아야 하는 가장 기본적인 개념이 바로 Promise의 상태(states)입니다. 여기서 말하는 상태란 프로미스의 처리 과정을 의미합니다. new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.

- Pending(대기) : Initial State, before the Promise succeeds or fails. 비동기 처리 로직이 아직 완료되지 않은 상태
- Fulfilled(이행) : Completed Promise. 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
- Rejected(실패) : Failed Promise, throw an error. 비동기 처리가 실패하거나 오류가 발생한 상태

The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.
If the promise gets rejected, it will jump to the catch() method.

프로미스 에러 처리는 가급적 catch()를 사용한다.

`mongoose.connect()`는 Promise를 return한다. Promise가 성공적으로 return되면, .then()에 정의된 callback function을 Promise가 reject되면 에러가 발생하여 .catch()에 정의된 callback function을 실행한다.

```
mongoose
  .connect()
  .then(() => console.log("MongoDB Connected..."))
  .catch((err) => console.log(err.massage));
```

### 💥 Async & Await

Await is basically syntactic sugar (사람이 이해하기 쉽게 만든 것) for Promises. It makes your asynchronous code look more like synchronous/procedural code, which is easier for humans to understand.

async와 await는 자바스크립트의 비동기 처리 패턴 중 가장 최근에 나온 문법입니다. 기존의 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성할 수 있게 도와주죠. 여기서 개발자가 읽기 좋은 코드란 code를 위에서 아래로 순차대로 실행할 수 있는 코드를 의미합니다. 우리는 위에서부터 아래로 한 줄 한 줄 차근히 읽으면서 사고하는 것이 편합니다. 그렇게 프로그래밍을 배웠으니까요.
async/await의 기반은 promise라는 사실은 매우 중요하다. 사실, 우리가 쓰는 모든 async 함수는 promise를 리턴하고, 모든 await 함수는 일반적으로 promise가 됩니다.

The await keyword is used in an async function to ensure that all promises returned in the async function are synchronized. Await eliminates the use of callbacks in .then() and .catch(). In using async and await, async is prepended when returning a promise, await is prepended when calling a promise. try and catch are also used to get the rejection value of an async function.

async & await 기본 문법:

이제 async await의 기본 문법을 알아보겠습니다.

```
async function 함수명() {
  await 비동기_처리_메서드_명();
}
```

먼저 함수의 앞에 async 라는 예약어를 붙입니다. 그러고 나서 함수의 내부 로직 중 HTTP 통신을 하는 비동기 처리 코드 앞에 await를 붙입니다. 여기서 주의하셔야 할 점은 **비동기 처리 메서드가 꼭 프로미스 객체를 반환**해야 await가 의도한 대로 동작합니다.

일반적으로 await의 대상이 되는 비동기 처리 코드는 Axios 등 프로미스를 반환하는 **API 호출 함수**입니다.

async & await 예외 처리:

async & await에서 예외를 처리하는 방법은 바로 try catch입니다. 프로미스에서 에러 처리를 위해 .catch()를 사용했던 것처럼 async에서는 catch {} 를 사용하시면 됩니다.

```
app.get("/", async (req, res) => {
  try {
    const items = await Item.find().sort({ date: -1 });
    if (!items) throw Error("No items");

    res.status(200).json(items);
  } catch (err) {
    console.error(err.message);
  }
});
```

### Promise를 Async/Await으로 변환하기

Promise 방식:
```
function getFirstUser() {
    return getUsers()
       .then(function(users) {
          return users[0].name;})
       .catch(function(err) {
        return {
          name: 'default user'
        };
    });
}
```

Async/Await 방식:
```
async function getFirstUser() {
    try {
        let users = await getUsers();
        return users[0].name;
    } catch (err) {
        return {
            name: 'default user'
        };
    }
}
```

자, 이제 promise로 구현하는 법과 async/await로 구현하는 법이 있다는 걸 알았습니다. 그럼 왜 promise를 알아야 하는걸까요?

1. 기다리지(await) 않는 상황
   만약 그냥 호출한다면,
   
   `let users = getFirstUser();`
   
   기다리지(await) 않았지만, 자동으로 error를 뿜지 않습니다!
   사실, await를 써야하는 의무는 없어요. 단지 쓰지 않는다면, user는 resolved 값이 아니라 promise 객체를 가리킬거에요. 그리고 많은 것들을 할 수 없게 되겠죠.
   javascript는 엄격한 타입선언을 하지 않기 때문에, user 변수로 무언가를 할때까지 드러나지 않을거고 아마 내가 원하는 곳에서 null 값을 줄거에요.
   비동기 함수가 저절로 wait 하지 않는다는 사실을 잊지 마세요.
   당신이 반드시 await 해야합니다. 하지 않는다면 예상한 값 대신에 promise 객체를 받게 될거에요.
   물론 promise 객체를 받아오도록 의도한거라면 괜찮아요. 그러면 promise 객체로 더 많은 것을 컨트롤 할 수 있습니다. 예를 들면 memoizing promises 같은 것들이요.

이 글의 중요한 점은 
💥 **promise를 이해하지 못하면 async/await를 사용하면서 진짜 진짜 이해하기 어려운 케이스와 버그를 만나게 된다**


## 💥 Javascript Closure & Hoisting

호이스팅(Hoisting)의 개념: 함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것을 말한다.

- 자바스크립트 함수는 실행되기 전에 함수 안에 필요한 변수값들을 모두 모아서 유효 범위의 최상단에 선언한다.
  자바스크립트 Parser가 함수 실행 전 해당 함수를 한 번 훑는다.
  함수 안에 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 실행시킨다.
  유효 범위: 함수 블록 {} 안에서 유효

- 즉, 함수 내에서 아래쪽에 존재하는 내용 중 필요한 값들을 끌어올리는 것이다.
  실제로 코드가 끌어올려지는 건 아니며, 자바스크립트 Parser 내부적으로 끌어올려서 처리하는 것이다.
  실제 메모리에서는 변화가 없다.

Hoisting 대상:

**var 변수 선언**과 **function 함수선언문**에서만 호이스팅이 일어난다.
  var 변수/함수의 **선언**만 위로 끌어 올려지며, **할당**은 끌어 올려지지 않는다.
  let/const 변수 선언과 함수표현식에서는 호이스팅이 발생하지 않는다.

```
// Javascript에서는 변수/함수가 program에 정의되어 있으면, program내에 어느 곳에서도 접근이 가능하다.
// getName()의 호출보다 getName()의 정의가 더 늦게 되지만, 함수선언문으로 정의된 함수는 접근가능하다. 
getName();  // Shin

// x는 정의되어 있지만, 7이란 값을 받기 전이므로, x의 값은 undefined이다.
console.log(x); // undefined
// y는 program에 정의되어 있지 않기 때문에, error가 발생한다.
console.log(y); // uncaught referenceError: y is not defined

// arrow function이나 함수표현식으로 작성한 함수는 var변수에 담겨있기 때문에, 
// 함수를 assign하기 전에는 위의 x처럼 variable로 다뤄진다.
getID(); // uncaught typeError: getID is not a function
getID; // undefined

var x = 7;
function getName() {
    console.log("Shin");
}

var getID = () => {
    console.log("ID1");
};
```

간단한 예시 (var 변수 vs let/const 변수)

```
console.log("hello");
var myname = "HEEE"; // var 변수
let myname2 = "HEEE2"; // let 변수
```

```
// 위의 결과와 동일하다.
// 이처럼 var로 정의된 변수들은 값을 assign하기 전에 프로그램의 맨 위로 올라오게 된다.
var myname; // [Hoisting] "선언"
console.log("hello");
myname = "HEEE"; // "할당"
let myname2 = "HEEE2"; // [Hoisting] 발생 X
```


간단한 예시 (함수선언문 vs 함수표현식)

```
foo();
foo2();

function foo() { // 함수선언문
console.log("hello");
}
var foo2 = function() { // 함수표현식
console.log("hello2");
}
```

```
// 위와 동일
var foo2; // [Hoisting] 함수표현식의 변수값 "선언"

function foo() { // [Hoisting] 함수선언문
console.log("hello");
}

foo();
foo2(); // undefined

foo2 = function() {
console.log("hello2");
}
```

Hoisting 함수선언문과 함수표현식에서 서로 다르게 동작하기 때문에 주의해야 한다.
변수에 할당된 함수표현식은 끌어 올려지지 않기 때문에 이때는 변수의 스코프 규칙을 그대로 따른다.

**Hoisting 우선순위:**

- 같은 이름의 var 변수 선언과 함수 선언에서의 호이스팅
- 변수 선언이 함수 선언보다 위로 끌어올려진다.

```
var myName = "hi";

function myName() {
console.log("yuddomack");
}

function yourName() {
console.log("everyone");
}

var yourName = "bye";

console.log(typeof myName);
console.log(typeof yourName);
```

```
// Hoisting의 결과
// 1. [Hoisting] 변수값 선언
var myName;
var yourName;

// 2. [Hoisting] 함수선언문
function myName() {
console.log("yuddomack");
}
function yourName() {
console.log("everyone");
}

// 3. 변수값 할당
myName = "hi";
yourName = "bye";

console.log(typeof myName); // > "string"
console.log(typeof yourName); // > "string"
```

값이 할당되어 있지 않은 변수와 값이 할당되어 있는 변수에서의 호이스팅

```
var myName = "Heee"; // 값 할당
var yourName; // 값 할당 X

function myName() { // 같은 이름의 함수 선언
console.log("myName Function");
}
function yourName() { // 같은 이름의 함수 선언
console.log("yourName Function");
}

console.log(typeof myName); // > "string"
console.log(typeof yourName); // > "function"
```

- 값이 할당되어 있지 않은 변수의 경우, 함수선언문이 변수를 덮어쓴다.
- 값이 할당되어 있는 변수의 경우, 변수가 함수선언문을 덮어쓴다.

TIP Hoisting 사용 시 주의:

- 코드의 가독성과 유지보수를 위해 Hoisting이 일어나지 않도록 한다.
  호이스팅을 제대로 모르더라도 함수와 변수를 가급적 코드 상단부에서 선언하면, Hoisting 인한 스코프 꼬임 현상은 방지할 수 있다.
  let/const를 사용한다.
  
- var를 쓰면 혼란스럽고 쓸모없는 코드가 생길 수 있다. 그럼 왜 var와 호이스팅을 이해해야 할까?
  ES6를 어디에서든 쓸 수 있으려면 아직 시간이 더 필요하므로 ES5로 트랜스컴파일을 해야한다.
  따라서 아직은 var가 어떻게 동작하는지 이해하고 있어야 한다.


## JavaScript 모듈 시스템

1. Node.js의 module 시스템: CommonJS (module.exports, require)
2. Javascript ES6부터는 브라우저 단에서도 쉽게 JavaScript의 모듈화가 가능하도록 모듈 시스템이 추가되었다. (export, import)
   ES6 fashion을 사용하려면 ES6를 ES5로 바꿔주는 babel complier가 필요하다.

### CommonJS (module.exports, require)

Node.js 환경에서 실행되는 JavaScript는 모듈 시스템으로서 CommonJS 방식을 지원한다. 이 방식에서는 `module.exports` 객체를 이용하여 자신의 데이터를 외부로 내보낼 수 있고, `require()` 함수를 이용하여 외부 모듈의 데이터를 불러올 수 있다. 만약 Babel 등의 컴파일러를 사용한다면 뒤에서 설명할 ES6 기반의 모듈 내보내기 및 불러오기 방식을 사용해도 알아서 module.exports 객체 및 require() 함수 기반의 방식으로 변환될 것이다.

자신의 데이터를 외부로 내보내려면 module.exports 변수에 내보내고자 하는 데이터들을 담은 객체를 지정해주면 된다.

```
// Item.js file
const Item = mongoose.model("item", ItemSchema);

// export Item variable, so that other files can access Item variable.
module.exports = Item;
```

외부 모듈의 데이터를 불러오려면 require("경로") 함수의 반환 값을 변수에 대입하면 된다. require() 함수가 반환하는 것은 해당 모듈의 module.exports 객체이다.

```
// Items.js file
const Item = require(".models/Item");
```

### ES6 with babel complier (export, import)

이는 브라우저 단에서도 쉽게 JavaScript의 모듈화가 가능하도록 ES6부터 도입된 방식이다. 모듈화 시스템답게 각각의 모듈(파일)마다 독립적인 파일 스코프를 가지고 있어서, 모듈 내에 var로 선언한 변수는 더 이상 window 객체의 프로퍼티가 아닌 파일 스코프의 변수로 존재하게 된다. 즉 기본적으로는 다른 모듈의 데이터를 참조할 수 없기 때문에 충돌도 발생하지 않는다.

이때 다른 모듈의 데이터를 참조하거나 자신의 데이터를 노출시키고 싶을 때 사용하는 것이 바로 export, import 키워드이다.

```
이러한 모듈 시스템을 브라우저에서 사용하려면 <script> 태그에 type="module" 어트리뷰트를 추가해야 한다.
그러면 그 안에 작성된 JavaScript 코드들은 ES6 기반의 모듈 내보내기 및 불러오기 방식을 지원하게 된다.
이때 불러오는 파일이 모듈임을 명확히 하기 위해 <script type="module"> 태그로 불러오는 JavaScript 파일의 확장자는 mjs로 설정하도록 권장되고 있다.
```

ES6 기반의 모듈 시스템은 CommonJS 방식에 비해 코드의 직관성이 좋고, 비동기 방식으로 작동하면서 불러오는 모듈의 실제로 사용되는 부분들만 로드하기 때문에 성능적으로도 효율적이라고 할 수 있다. 그러나 이는 아래와 같은 단점들을 가지고 있어서 아직까지는 Webpack 등의 모듈 번들러를 이용하여 미리 의존성이 해결된 형태의 번들 JavaScript 파일을 제공하는 방식이 더 선호되는 경향이 있다.

- IE(인터넷 익스플로러)를 포함한 몇몇 구형 브라우저는 ES6 모듈 시스템을 지원하지 않는다.
- 브라우저의 ES6 모듈 시스템을 사용하더라도 어차피 트랜스파일링이나 번들링은 필요하다.
  = 아직 지원하지 않는 기능(Bare import 등)들이 꽤 있다. (ECMAScript modules in browsers 참고)
- 점차 해결되고는 있지만 아직 몇 가지 이슈가 있다. (ECMAScript modules in browsers 참고)

모듈 내보내기 (export)

```
// Named Export : 정해진 이름으로 내보내기
export 변수/함수/클래스 선언문;
export { 변수명/함수명/클래스명 };
export { 변수명/함수명/클래스명 as 다른 이름 };

// Default Export : 기본 내보내기 (이름을 정하지 않음. 최대 하나만 가능.)
export default 선언문 또는 값;
export { 변수명/함수명/클래스명 as default };
```

모듈 불러오기 (import)

```
import A, { B, C } from 경로; // A는 Default Export, B와 C는 Named Export

import { B as b, C as c } from 경로; // 원하는 이름으로 로드

import \* as obj from 경로; // Export 된 모든 것들을 하나의 객체 형태로 로드 (불필요한 것도 가져오면 번들링 시 비효율을 야기)

import { default as A } from 경로; // "import A from 경로"와 동일 (default)
```

### ReactJS에서 NPM 패키지 모듈 불러오기

NPM 패키지 모듈들은 **CommonJS**를 기본 모듈 시스템으로 채택한다.

즉, 모듈을 내보내고 불러오는 것에 있어 require, module.exports 등을 사용한다는 말이다.

그러나 실제로 ReactJS 등의 라이브러리를 활용하여 Frontend 개발을 할 때는 NPM 패키지 모듈을 불러오기 위해 ES6 문법의 코드를 작성하는 경우가 많다(import, export 등). 

그런데 왜 문제가 발생하지 않을까? 이는 Babel 등의 컴파일러가 import, export 등의 코드를 CommonJS 기반의 코드로 변환해주기 때문이다. 
그러고 나면 Webpack에 의해 JavaScript 모듈들의 번들링이 가능해진다. 변환 규칙은 대략 다음과 같다(실제로는 더 복잡할 수 있다).


### ES6 import 사용법

Node has experimental support for ES modules. To enable them we need to make some changes to the package.json file. Before following the steps make sure that Node is installed. Below are the steps to achieve the same.

CommonJS를 모듈 시스템을 채택했던 Node.js에서는 import, export와 같은 ES 모듈을 사용하려면 Babel과 같은 트랜스파일러(transpiler)를 사용했어야 했는데요. 

ode.js 버전 13.2부터 ES 모듈 시스템에 대한 정식 지원이 시작됨에 따라 다른 도구 없이 Node.js에서 손쉽게 ES 모듈을 사용할 수 있게 되었습니다. 🎉

1. 프로젝트 단위로 ES 모듈 적용: 

In the package.json file add **“type” : “module”**. Adding this enables ES6 modules.
The package.json file should look like this:

Node.js에서 ES 모듈을 사용하는 두번째 방법은 package.json 파일 설정을 통해 전체 파일에 적용하는 것입니다. 모든 파일의 확장자를 일일이 바꾸지 않고, 프로젝트 전체에 ES 모듈을 적용하고 싶을 때 적합한 방법입니다.

먼저 프로젝트의 package.json 파일을 열고, 최상위에 type 항목을 module로 설정합니다.

package.json 생성

> `npm init`

```
//package.json
{
  "name": "index",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

2. 파일 단위로 ES 모듈 적용:

Node.js에서 ES 모듈을 사용하는 방법은 파일의 확장자를 js 대신에 mjs를 사용하는 것입니다. 프로젝트에서 부분적으로 ES 모듈을 사용할 때 가장 쉽고 빠르게 적용할 수 있는 방법입니다.

time.js와 time.test.js 파일의 확장자를 mjs 바꾸고, ES 모듈의 import와 export 키워드를 사용하도록 코드를 수정합니다.

```
// time.mjs
import moment from "moment";

export function now() {
return moment().format();
}
```

```
// time.test.mjs
import { now } from "./time";

console.log("Now:", now());
```

time.test.mjs 파일을 실행을 해보면 Node.js가 time 모듈을 찾지 못하는 현상을 보게 되실 겁니다.

$ node src/time.test.mjs
internal/modules/run_main.js:54
internalBinding('errors').triggerUncaughtException(
^

Error [ERR_MODULE_NOT_FOUND]: Cannot find module 

이 부분이 Node.js에서 ES 모듈울 처음 사용할 때 가장 많이 실수를 하게되는 부분인데요. Node.js에서 import 키워드로 프로젝트 내부 모듈을 불러올 때는 반드시 **확장자까지 포함**해서 경로를 명시를 해줘야 합니다. 이는 브라우저에서 import가 작동하는 방식과 맞추기 위해서 의도적으로 설계된 부분이라고 합니다.

확장자를 포함해서 경로를 명시해주면 정상적으로 작동합니다.

```
// time.test.mjs
import { now } from "./time.mjs";

console.log("Now:", now());
$ node src/time.test.mjs
Now: 2020-05-23T18:10:20-04:00
```

이상으로 Node.js에서 ES 모듈의 import와 export 키워드를 사용하는 2가지 방법에 대해서 알아보았습니다. 참고로 Node.js 버전 13.2 미만에서도 버전 12 이상에서는 Node.js를 실행할 때 --experimental-module 옵션을 넘기면 동일한 방법으로 ES 모듈을 사용할 수 있으니 참고바라겠습니다.

## JSX에 대해 

react js는 js 대신 jsx 라는 특수한 extension을 사용한다. 하지만 js를 사용해도 아무런 문제는 없다.

JSX stands for JavaScript XML. It is simply a syntax extension of JavaScript.

아래 변수 선언을 살펴봅시다.

> `const element = <h1>Hello, world!</h1>;`

위에 희한한 태그 문법은 문자열도, HTML도 아닙니다.

JSX라 하며 JavaScript를 확장한 문법입니다. UI가 어떻게 생겨야 하는지 설명하기 위해 React와 함께 사용할 것을 권장합니다. JSX라고 하면 템플릿 언어가 떠오를 수도 있지만, JavaScript의 모든 기능이 포함되어 있습니다.

JSX는 React “엘리먼트(element)” 를 생성합니다.

React는 JSX 사용이 필수가 아니지만, 대부분의 사람은 JavaScript 코드 안에서 UI 관련 작업을 할 때 시각적으로 더 도움이 된다고 생각합니다. 또한 React가 더욱 도움이 되는 에러 및 경고 메시지를 표시할 수 있게 해줍니다.

아래 예시에서는 name이라는 변수를 선언한 후 중괄호로 감싸 JSX 안에 사용하였습니다.

```
const name = 'Josh Perez';
const element = <h1>Hello, {name}</h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);
```

JSX의 중괄호 안에는 유효한 모든 JavaScript 표현식을 넣을 수 있습니다. 예를 들어 2 + 2, user.firstName 또는 formatName(user) 등은 모두 유효한 JavaScript 표현식입니다.

컴파일이 끝나면, JSX 표현식이 정규 JavaScript 함수 호출이 되고 JavaScript 객체로 인식됩니다.

즉, JSX를 if 구문 및 for loop 안에 사용하고, 변수에 할당하고, 인자로서 받아들이고, 함수로부터 반환할 수 있습니다.

### ES7+ React/Redux/React-Native snippets

VScode extension인 `ES7+ React/Redux/React-Native snippets`을 download하면 `rafce`만 code에 입력하면 arrow function이 자동적으로 완성된다.

이는 React Js 코드 특히 components를 작성할 떄, 매우 간편하게 사용할 수 있다.

```
// rafc
import React from 'react';

export const $1 = () => {
  return <div>$0</div>;
};

// rafce
import React from 'react';

const $1 = () => {
  return <div>$0</div>;
};

export default $1;
```

## Bootstrap and Reactstrap or Material-Ui

`bootstrap`은 frontend dev에 대한 구조를 미리 만들어둔 프레임워크로 UI stlye에 대한 기본적인 css, js를 제공합니다.
react js 뿐만 아니라 frontend dev 전체에 사용할 수 있는 매우 유용한 프레임워크입니다.

1. client/public에 있는 index.html에 bootstrap homepage에 있는 css link tag, js script tag을 copy & paste해서 bootstrap을 사용하는 방법이 있고,
2. source code를 copy & paste하는 방법이 있고,
3. npm package manager를 이용해 `npm install bootstrap`을 이용하여 사용할 수 있다.

bootstrap: https://getbootstrap.com/docs/5.1/getting-started/download/

`reactstrap`은 bootstrap component를 react component로 사용할 수 있게 만들어 주는 framework이다.

`material-ui`은 `reactstrap`처럼 다른 프로그래머가 미리 만들어둔 react component를 가져다 쓸 수 있기 떄문에 매우 편하다.
이처럼 다른 사람이 만들어둔 source code를 찾아 copy & paste만 잘해도 된다.

reactstrap: https://reactstrap.github.io/?path=/docs/components-navbar--navbar

material-ui는 react js에서 쓸 수 있는 react components을 모아둔 framework이다.

material-ui가 2022년 기준 react js에서 가장 많이 쓰이는 framework이다.

`material-ui`은 `reactstrap`처럼 다른 프로그래머가 미리 만들어둔 react component를 가져다 쓸 수 있기 떄문에 매우 편하다.
이처럼 다른 사람이 만들어둔 source code를 찾아 copy & paste만 잘해도 된다.

material-ui: https://mui.com/

## Curly brackets  {} vs Parentheses () in Javascript Arrow Function

### In Javascript:

- Curly brackets: after an arrow function they represent a code block, which consists of zero or more grouped statements within the curly brackets.

arrow function에서 body부분에 Curly brackets가 쓰이면 이는 code block, 즉 여러개의 code를 묶어 놓은 것으로 인식하기 떄문에 `return` keyword가 다른 function들 처럼
반드시 필요하다.

`return`이 없으면, 이 함수는 local variable만 생성할 뿐 값을 만들어 내지 않기 떄문에, 값이 `undefined`가 된다.

```
const jsBrackets = x => {
return x > 3 ? true : false
}
```

If the function can be written on one line (as the example above can, it can be shortened to exclude both the curly brackets and the return word, as below.

`const jsBrackets = x => x > 3 ? true : false`

- Parentheses: are used instead of curly brackets after an arrow function to return an object. 

For example, they are used in map, filter, and reduce functions.

```
const numbers = [1,2,3,4]
// OKAY
numbers.map(number => number \* 2)
numbers.map(number => (number \* 2))
numbers.map(number => {return number \* 2})

// 위의 세 경우와 다르게 return keyword가 없는 code block은 반환값이 없어 undefined값이 된다.
const newnumbers = numbers.map(number => {number \* 2});
console.log("newnumbers");
```

이를 확인하려면, browser에서 F12를 열거나, 마우스 오른쪽 클릭 후 inspect를 클릭해 개발자 모드로 들어간다.

Source tab에서 js파일에 breakpoint를 걸고 실행시켜보면, scope/global scope을 통해 값을 볼 수 있다.

### Using JSX in React:

- Curly brackets: are a special syntax to let the JSX parser know that it needs to interpret the contents between them as javascript instead of text.

`const items =this.state.toDoList.map((item) => <li>{item}</li> )`

Since {item} is in curly brackets JSX interprets that as to find the variable item back in javascript land and to insert it within the `<li></li>`s.

- Parentheses: are used to wrap multiline codes of Javascript after the return statement in order for your code to compile.

```
render () {
return ( <li> {item}</li>,
<SomeComponent /> )
}
```

If you only have one line of code, you don’t need the parentheses.

```
render () {
return <li> {item}</li>
}
```

```
// jsx syntax
const items = { {id: 1, name: eggs}, {id: 2, name: milk} }
{ items.map(item => (
 <tr key={items.id}>
    <td>{ items.name }</td>
 <tr>
)) }
```

react js를 이용할 때, javascript 코드를 jsx syntax에서 사용하고 싶으면 curly brackets {} 안에서 정의하면 된다.
react js에서 array를 하나씩 iterate해야할 경우 `array.map()` 함수를 이용하고, 그 안에 callback함수인 arrow function을 정의한다.

react js는 jsx이기 때문에 `array.map((param) => {body})`가 아니라 `array.map((param) => (body))`처럼 body에도 parentheses를 사용해야 한다.

`map()`은 javascript code이기 때문에 `{ array.map((param) => (body))}`과 같이 curly brackets {} 안에서 정의하면 된다.

## Typescript

TypeScript is a programming language developed and maintained by Microsoft. It is a strict syntactical superset of JavaScript and adds optional static typing to the language.

Javascript의 superset으로 Java와 같이 변수를 선언할 때, 그 변수의 type을 지정해 주어야만 한다.


# Fullstack App development Example

Learn the MERN Stack

M: MongoDB (Database)
E: Express (Backend)
R: React JS (Frontend)
N: Node JS

## Beginning from scratch

First we will start with the server side and database.

### 1. Create empty folder and create `package.json`

Open Terminal (CMD in window) and type the following command:

> `mkdir MERN_SHOPPING_LIST ; cd MERN_SHOPPING_LIST`

이는 MERN_SHOPPING_LIST라는 새로운 folder를 만드는 command `mkdir MERN_SHOPPING_LIST` 와
그 folder로 이동하는 command `cd MERN_SHOPPING_LIST`가 동시에 실행됩니다.

- `mkdir <foldername>`: make directory. folder 생성
- `cd <fodlername>`: change directory. folder로 이동
- `ls`: 현재 folder에 있는 files을 반환

> `npm init`

- description: Shopping List built with the MERN stack
- entry point (index.js) server.js
- type: "module"
- author: Heechul Shin
- license: (ISC) MIT

이는 새로운 package.json을 만들어 냅니다.

package.json에 "type": "module"을 추가 해야지만 file을 내보내고/가져올 때, module.export/require을 사용하는 CommonJS 대신
**import/export**의 형식을 지원하는 ES6을 사용할 수 있습니다.

### 2. Install Dependencies for Backend and Database:

- `express`: Backend (Server) framework
- `mongoose`: mongodb api
- `concurrently`: run more than one `npm` scripts at a time, sos that we are able to run the server and the client at a same time.
- `nodemon`: constantly watch our backend and reload once we save (auto refresh).
- `-D`: stands for development dependency because it's not needed for production.
- `dotenv`: set the environment variable so that hide all of our secret information.

  > `npm i express mongoose concurrently dotenv`

  nodemon은 개발할 때만 사용할 dependency이기 때문에, -D를 붙혀 실제 production에서는 설치하지 않는다.

  > `npm i -D nodemon`

### 3. Add { "start", "server" } in `package.json` script & Create { app.js & server.js & .gitignore & .env } files

```
// package.json
"scripts": {
  "start": "node server.js",
  "server": "nodemon server.js"
},
```

- start: start the server. but need to restart the server after every server-side change.
- server: start the server. nodemon continuously watch the server, and we won't have to keep updating it.

server는 개발할 때만 사용할 command이다.

To use these command, type:

> `npm start`

run the command that is defined in "start" key.
This is same as `node server.js`

> `npm run server`

we put our database connection configuration in the .env file. So, we don't want .env to deploy.

- Add `.env` to .gitignore.
- Add `node_modules` and `package-lock.json` to .gitignore

create a folder called `config` and inside create a file called `index.js`

```
// ./config/index.js
import dotenv from "dotenv";

// allow to use configurations in .env file with `process.env.${name}`
// dotenv.config({ silent: process.env.NODE_ENV === "production" });
dotenv.config();

export default {
  PORT: process.env.PORT || 5000,
  MONGO_URI: process.env.MONGO_URI // MONGO_URI is environment variable and is defined in .env file
};
```

- In `app.js`, define our basic application.
- In `server.js`, it simply listen the connections on the specified host and port in app.js

### 4. Create Mongo DataBase in the cloud storage and Create Database schemas

We need a MongoDB URL to be able to connect to.

- Create Database = { Cluster Tier: M0 Sandbox (Free),
  Cloud Provider: AWS
  }

- Set User name & User password, Network access IP Address
- Connect => "Connet your application" => DRIVER: Node.js
- Get mongoDBURI

- MongoDB URL (MongoDB Atlas): https://www.mongodb.com/cloud/atlas/lp/try2?utm_content=1217adtest_pmcopy_control&utm_source=google&utm_campaign=gs_americas_united_states_search_core_brand_atlas_desktop&utm_term=mongodb%20atlas&utm_medium=cpc_paid_search&utm_ad=e&utm_ad_campaign_id=12212624338&adgroup=115749704063&gclid=Cj0KCQiAxc6PBhCEARIsAH8Hff0GkAMWkv-SOoaFSdMgxQaEshcIGIyDHAaSqp-B-yPgW03BbW9DxxQaAhi8EALw_wcB

- Using this MongoDB URI, connect to the Database in app.js
- Define a database schemas in the seperate folder class models
- In models folder, define `Item.js` that returns Item table

### 5. Create routers

- create new folder 'routes' and inside create new folder 'api'.
- In api folder, create a file `items.js` and define rest api. (GET, POST, DELETE)
- We use Postman program to test our rest api.

now our basic server structure is done. we are going to work in the client side

### 6. Create client folder

- create new folder 'client'

> `mkdir client; cd client`

inside the client folder, create new react app

> `npx create-react-app .`

create-react-app은 기존의 package.json과는 다른 새로운 package.json을 만들어 내는데, 이 package.json에 "proxy" value를 적어놓는 것이 중요하다. proxy는 개발할 때만 쓰이기 때문에 나중에는 신경쓰지 않아도 된다.

예를 들어 `axios.get('http://localhost:5000/api/items')`와 같은 긴 주소명을
`axios.get('api/items')`와 같이 짧게 쓰는 것을 가능하게 만들어 준다.

```
// package.json in client folder
{
  "name": "client",
  "version": "0.1.0",
  "private": true,
  ...
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "proxy": "http://localhost:5000/"
}
```

우리는 두 개의 package.json이 있기 때문에 client folder에서 `npm start`를 입력하면 react가 실행되고,
MERN_SHOPPING_LIST folder에서 `npm start`를 입력하면 server.js가 실행된다.

우리는 이런 두 개의 command를 MERN_SHOPPING_LIST folder에서 동시에 사용하고 싶다.

이때, 우리가 설치한 dependency `concurrently`가 역할을 해준다.

- MERN_SHOPPING_LIST folder의 package.json에 "client": "cd client && npm start" 또는 "client": "npm start --prefix client"를 적는다.

  이는 사용자가 client folder를 들어가지 않고도 client folder의 react app을 실행시킨다.

Run the React client only

> `npm run client`

- MERN_SHOPPING_LIST folder의 package.json에 "client": "client-install": "npm install --prefix client" 또는 "client": "cd client && npm install"를 적는다.

  이는 사용자가 client folder를 들어가지 않고도 client folder의 dependencies를 install할 수 있게 해준다.

Install dependencies for client

> `npm run client-install`

server side의 dependencies를 설치하려면, MERN_SHOPPING_LIST folder에서 다음을 입력한다.

> `npm install`

concurrently 사용법:

Remember to surround separate commands with quotes:

> `concurrently "command1 arg" "command2 arg"`

Otherwise concurrently would try to run 4 separate commands: command1, arg, command2, arg.

In package.json, escape quotes:

> `"start": "concurrently \"command1 arg\" \"command2 arg\""`

- MERN_SHOPPING_LIST folder의 package.json에 "dev": "concurrently \"npm run server\" \"npm run client\""를 적는다.

  이는 concurrently를 이용하여 사용자가 client와 server를 동시에 실행할 수 있게 해준다.

Run the client & server with concurrently

Server runs on http://localhost:5000 and client on http://localhost:3000

> `npm run dev`

```
// package.json in mern_shopping_list folder
{
  "name": "mern_shopping_list",
  "version": "1.0.0",
  "description": "Shopping List built with the MERN stack",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "server": "nodemon server.js",
    "client": "npm start --prefix client",
    "dev": "concurrently \"npm run server\" \"npm run client\"",
    "client-install": "npm install --prefix client"
  },
  ...
}
```

### 7. Install dependencies for client

Go to the client folder and install dependencies.

> `cd client`

- `bootstrap`: frontend dev에 대한 구조를 미리 만들어둔 프레임워크입니다. 기본적인 css, js를 제공합니다.
- `reactstrap`: bootstrap component를 react component로 사용할 수 있게 만들어 준다.
- `uuid`: generate random ID
- `react-transition-group`: exposes simple components useful for defining entering and exiting transitions.

> `npm i bootstrap reactstrap uuid react-transition-group`

### 8. src folder에 component folder를 만들기

- src folder에 component folder를 만든다.
- component folder에 AppNavbar.js를 만든다.

VScode extension인 `ES7+ React/Redux/React-Native snippets`을 download하면 `rafce`만 code에 입력하면 arrow function이 자동적으로 완성된다.

AppNavbar.js는 reactstrap의 Navbar Toggler component를 사용할 것이다.
이 Navbar를 클락하면 그 안에 있는 links가 보이는 형식이다.

reactstrap: https://reactstrap.github.io/?path=/docs/components-navbar--navbar

위의 링크로 가서 `component/navbar`를 가져온다.

### 9. Create src/components/ShoppingList.jsx

reactstrap: https://reactstrap.github.io/?path=/docs/components-listgroup--list-group

위의 링크로 가서 `component/ListGroup`를 가져온다.

server에 있는 data를 client에서 Get/Post/Delete하도록 간단히 만들어 준다.

### 10. Implementing Redux

client fodler에서 dependencies를 install한다.

> `cd client`

- `redux`:
- `react-redux`:
- `redux-thunk`:

> `npm i redux react-redux redux-thunk`

- client/src에 store.js 만들기
- App.js에 Provider 추가

